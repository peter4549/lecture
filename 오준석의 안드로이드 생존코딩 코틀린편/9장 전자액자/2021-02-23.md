# 9 전자액자
## 라이브러리 설정
* Anko: 인텐트, 다이얼로그, 로그 등을 구현하는 데 도움이 되는 라이브러리

## 9.3 (스텝 1) 프로바이더 사용하기
사진을 찍으면 내부 저장소에 저장되고 안드로이드의 미디어 데이터베이스에도 사진 정보가 저장된다.  
저장된 미디어 데이터는 콘텐츠 프로바이더(Contents Provider)를 사용해 다른 앱에 공개될 수 있다.  
콘텐츠 프로바이더란 앱의 데이터 접근을 다른 앱에 허용하는 컴포넌트이다.  
  
프로바이더를 이용하여 사진 정보를 가지고 오는 순서는 크게 다음과 같다.
1. 사진 데이터는 외부 저장소에 저장되어 있으므로 외부 저장소 읽기 권한을 앱에 부여한다.
2. 외부 저장소 읽기 권한은 위험 권한으로 실행 중에 사용자에게 권한을 허용하도록 한다.
3. contentResolver 객체를 이용하여 데이터를 Cursor 객체로 가지고 온다.  

다음 과정을 진행한다.
1. 프로바이더로 기기의 사진 경로 얻기
2. 매니페스트에 외부 저장소 읽기 권한 추가
3. 권한 확인
4. 권한 요청
5. 사용 권한 요청 응답 처리
6. 앱 실행

### 안드로이드 4대 컴포넌트
안드로이드에는 크게 4개의 중요 컴포넌트가 있다. 이를 4대 컴포넌트라고 지칭한다.
* 액티비티: 화면을 구성한다.
* 콘텐츠 프로바이더: 데이터베이스, 파일, 네트워크 데이터를 다른 앱에 공유한다.
* 브로드캐스트 리시버: 앱이나 기기가 발송하는 방송을 수신한다.
* 서비스: 화면이 없고 백그라운드 작업에 용이하다.

### 9.3.1 기기의 사진 경로얻기
프로바이더를 사용해 사진 정보를 얻으려면 contentResolver 객체를 사용해 데이터를 얻을 수 있다.  
다음은 외부 저장소에 저장된 모든 사진을 최신순으로 정렬하여 Cursor라는 객체를 얻는 코드이다.
```
val cursor: Cursor? = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,  // 1.
        null,  // 2. 가져올 항목 배열
        null,  // 3. 조건
        null,  // 4. 조건
        MediaStore.Images.ImageColumns.DATE_TAKEN + "DESC"  // 5. 찍은 날짜 내림차순
)
```
contentResolver 객체의 query() 메서드는 인자 5개를 받는다.
1. 첫 번째 인자는 어떤 데이터를 가져오느냐를 URI 형태로 저장한다. 사진 정보는 외부 저장소에 저장되어 있기 때문에 외부 저장소에 저정된 데이터를 가리키는 URI인 EXTERNAL_CONTENT_URI를 지정한다.

### 안드로이드 저장소
안드로이드 저장소는 크게 두 가지 영역으로 나뉜다.
* 내부 저장소: OS가 설치된 영역으로 유저가 접근할 수 없는 시스템 영역이다. 앱이 사용하는 정보와 데이터베이스가 저장된다.
* 외부 저장소: 컴퓨터에 기기를 연결하면 저장소로 인식되며 유저가 사용하는 영역이다. 사진과 동영상은 외부 저장소에 저장된다.

2. 두 번째 인자는 어떤 항목의 데이터를 가져올 것인지 String 배열로 지정한다. 가져올 데이터의 구조를 잘 모른다면 일반적으로 null을 지정한다. null을 지정하면 모든 항목을 가져온다.
3. 세 번째 인자는 데이터를 가져올 조건을 지정할 수 있다. 전체 데이터를 가져올 때는 null을 설정한다.
4. 네 번째 인자는 세 번째 인자와 조합하여 조건을 지정할 때 사용한다. 사용하지 않는다면 null을 설정한다.
5. 정렬 방법을 지정한다. 사진이 찍힌 날짜의 내림차순 정렬을 한다.

### 9.3.2 매니페스트에 외부 저장소 읽기 권한 추가
안드로이드 6.0(API 23)부터 모든 앱은 외부에서 리소스 또는 정보를 사용하는 경우 앱에서 사용자에게 권한을 요청해야 한다. 매니페스트에 권한을 나열하고 앱을 실행 중에 사용자에게 각 권한을 승인 받으면 된다.  
  
안드로이드 시스템에 의해서 권한은 '정상(normal)' 권한과 '위험(dangerous)' 권한으로 분류된다.

### 9.3.3 권한 확인
```
if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
        != PackageManager.PERMISSION_GRANTED) {
    // 권한이 허용되지 않음
}
```
앱에 권한이 있으면 PERMISSION_GRANTED가 반환되고, 없다면 PERMISSION_DENIED가 반환된다.

### 9.3.4 권한 요청
```
// 권한이 부여되었는지 확인 1.
if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
        != PackageManager.PERMISSION_GRANTED) {

    // 권한이 허용되지 않음 2.
    if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_EXTERNAL_STORAGE)) {
        // 이전에 이미 권한이 거부되었을 때 설명 3.
       alert("사진 정보를 얻으려면 외부 저장소 권한이 필수로 필요합니다", "권한이 필요한 이유") {
           yesButton {
               // 권한 요청
               ActivityCompat.requestPermissions(
                       this@MainActivity,
                       arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),
                       REQUEST_READ_EXTERNAL_STORAGE
               )
           }
           noButton {  }
       }.show()
    } else {
        // 권한 요청 4.
        ActivityCompat.requestPermissions(
                this@MainActivity,
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),
                REQUEST_READ_EXTERNAL_STORAGE
        )
    }
} else {
    // 권한이 이미 허용됨 5.
    getAllPhotos()
}
```
어떤 경우에는 사용자에게 권한이 왜 필요한지 알려줄 필요가 있다. 그렇지만 항상 권한에 대한 설명을 주저리주저리 한다면 사용하기 불편하다. 사용자가 한 번 권한을 거부한 적이 있을 때만 설명을 하는 것이 좋다.
2. shouldShowRequestPermissionRational() 메서드는 사용자가 전에 권한 요청을 거부했는지를 반환한다. true를 반환하면 거부를 한 적이 있는 것이다.

### 9.3.5 사용 권한 요청 응답 처리
사용자가 권한을 요청하면 시스템은 onRequestPermissionResult() 메서드를 호출하고 사용자의 응답을 전달한다. 권한이 부여되었는지 확인하려면 이 메서드를 오버라이드해야 한다.
```
override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults)
    
    when (requestCode) {
        REQUEST_READ_EXTERNAL_STORAGE -> {
            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // 권한 허용됨
                getAllPhotos()
            } else {
                // 권한 거부
                toast("권한 거부 됨")
            }
            return
        }
    }
}
```
getResults 배열에는 요청한 권한들의 결과가 전달된다. 지금은 하나의 권한만 요청했기 때문에 0번 인덱스값만 확인한다. 권한이 승인되면 PERMISSION_GRANTED를 반환하고, 거부되면 PERMISSION_DENIED를 반환한다.

9.3.6 앱 실행
```
// 1.
if (cursor != null) {
    while (cursor.moveToNext()) {
        // 사진 경로 Uri 가져오기 2.
        val uri = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA))
        Log.d("MainActivity", uri)
    }
    cursor.close() // 3.
}
```
#### MediaStore.MediaColumns.DATA is deprecated, and I want to load images from gallery to my app
https://stackoverflow.com/questions/57685725/mediastore-mediacolumns-data-is-deprecated-and-i-want-to-load-images-from-galle

1. 사진 정보를 담고 있는 Cursor 객체는 내부적으로 데이터를 이동하는 포인터를 가지고 있어서 moveToNext() 메서드로 다음 정보로 이동하고 그 결과를 true로 반환한다. while 문을 사용하면 모든 데이터를 순회할 수 있다. 만약 사진이 없다면 Cursor 객체는 null이다.
2. 사진의 경로가 저장된 데이터베이스의 컬럼명은 `_ID` 상수에 
3. Cursor 객체를 더 이상 사용하지 않을 때는 close() 메서드로 닫아야 한다. 만약 닫지 않으면 메모리 누수(memory leak)가 발생한다.

### 매모리 누수
메모리 누수란 메모리가 해제되지 않는 상황이 지속되는 것을 말한다. 메모리 누수가 쌓이면 잘 동작하던 폰이 느려지고 앱이 죽을 수 있다.

#### MediaStore.MediaColumns.DATA is deprecated, and I want to load images from gallery to my app
### Copper
https://github.com/cashapp/copper
